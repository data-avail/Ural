// Generated by CoffeeScript 1.3.3
(function() {
  var __hasProp = {}.hasOwnProperty;

  define(function() {
    var convert, _convert, _convertField, _convertToken, _joinData, _joinSentences, _val,
      _this = this;
    _val = function(val, tokenName) {
      var mt;
      if (typeof val === "string") {
        return "'" + (encodeURIComponent(val).replace("\'", "%ff")) + "'";
      } else if (val instanceof Date) {
        mt = moment(new Date(val));
        if (tokenName === "$lte") {
          mt.add("d", 1);
        }
        return "DateTime'" + (mt.format("YYYY-MM-DD")) + "'";
      } else {
        if (typeof val === "object") {
          return JSON.stringify(val);
        } else if (val) {
          return val.toString();
        } else {
          return "null";
        }
      }
    };
    _convertToken = function(fieldName, tokenName, val) {
      var res;
      switch (tokenName) {
        case "$eq":
          return "" + fieldName + " eq " + (_val(val));
        case "$lte":
          return "" + fieldName + " le " + (_val(val, tokenName));
        case "$gte":
          return "" + fieldName + " ge " + (_val(val));
        case "$LIKE":
          return "indexof(" + fieldName + ", '" + val + "') ne -1";
        case "$like":
          return "indexof(toupper(" + fieldName + "), '" + (val.toUpperCase()) + "') ne -1";
        case "$in":
          if (val.length <= 10) {
            return "(" + ((val.map(function(x) {
              return "" + fieldName + " eq " + (_val(x));
            })).join(" or ")) + ")";
          } else {
            res = {};
            res[fieldName] = val.map(function(x) {
              return _val(x);
            });
            return res;
          }
          break;
        default:
          throw "can't convert token expression { " + fieldName + " : { " + tokenName + " : " + val + " }}";
      }
    };
    _convertField = function(fieldName, field) {
      var t, tokenName, _results;
      _results = [];
      if (typeof field === "object") {
        for (tokenName in field) {
          if (!__hasProp.call(field, tokenName)) continue;
          t = _convertToken(fieldName, tokenName, field[tokenName]);
          if (t) {
            _results.push(t);
          }
        }
      } else {
        _results.push(_convertToken(fieldName, "$eq", field));
      }
      return {
        str: _results.filter(function(f) {
          return typeof f === "string";
        }).join(" and "),
        data: _results.filter(function(f) {
          return typeof f === "object";
        })[0]
      };
    };
    _convert = function(sentence) {
      var expr, field, _results;
      _results = [];
      for (field in sentence) {
        if (!__hasProp.call(sentence, field)) continue;
        if (field === "$and") {
          if (sentence[field].length) {
            expr = sentence[field].map(function(s) {
              return _convert(s);
            });
            if (expr.length) {
              _results.push({
                name: "and",
                expr: expr
              });
            }
          }
        } else if (field === "$or") {
          if (sentence[field].length) {
            expr = sentence[field].map(function(s) {
              return _convert(s);
            });
            if (expr.length) {
              _results.push({
                name: "or",
                expr: expr
              });
            }
          }
        } else {
          expr = _convertField(field, sentence[field]);
          if (expr) {
            _results.push({
              name: null,
              expr: expr
            });
          }
        }
      }
      return _results;
    };
    _joinSentences = function(sentences) {
      var res, st, _i, _len;
      res = "";
      for (_i = 0, _len = sentences.length; _i < _len; _i++) {
        st = sentences[_i];
        if (res) {
          res += " and ";
        }
        if (st.name === "and" || st.name === "or") {
          res += "(" + (st.expr.map(function(e) {
            return _joinSentences(e);
          }).filter(function(e) {
            return e;
          }).join(" " + st.name + " ")) + ")";
        } else {
          res += st.expr.str;
        }
      }
      return res;
    };
    _joinData = function(sentences) {
      var d, e, p, res, s, st, _i, _j, _len, _len1, _ref, _ref1;
      res = {};
      for (_i = 0, _len = sentences.length; _i < _len; _i++) {
        st = sentences[_i];
        if (st.name === "and" || st.name === "or") {
          _ref = st.expr;
          for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
            e = _ref[_j];
            d = _joinData(e);
            for (s in d) {
              if (!__hasProp.call(d, s)) continue;
              res[s] = d[s];
            }
          }
        } else {
          if (st.expr.data) {
            _ref1 = st.expr.data;
            for (p in _ref1) {
              if (!__hasProp.call(_ref1, p)) continue;
              res[p] = st.expr.data[p];
            }
          }
        }
      }
      return res;
    };
    /*
      Convert frameworkFilter to filter which is complied to format of odata query expressions (odata.org)
      Options
        - **$page** {Int, default:undefined}, page number to return
        - **$itemsPerPage** {Int, default:10}, number of items conteined in one page
        - **any field name**, field name with filter condition, see mongodb conventions
        @param {Object} [options] structure to convert
        @return converted structure {$skip, $top, $filter}
        @api public
    */

    convert = function(frameworkFilter) {
      var arg, args, expand, field, filter, filterData, itemsPerPage, orderby, page, res, sts, _ref;
      for (field in frameworkFilter) {
        if (!__hasProp.call(frameworkFilter, field)) continue;
        if (field === "$page") {
          page = frameworkFilter[field];
        } else if (field === "$itemsPerPage") {
          itemsPerPage = frameworkFilter[field];
        } else if (field === "$expand") {
          expand = frameworkFilter[field];
        } else if (field === "$orderby") {
          orderby = frameworkFilter[field];
        } else if (field === "$filter") {
          sts = _convert(frameworkFilter[field]);
          filter = _joinSentences(sts);
          filterData = _joinData(sts);
        } else if (field === "$args") {
          if (frameworkFilter[field]) {
            args = {};
            _ref = frameworkFilter[field];
            for (arg in _ref) {
              if (!__hasProp.call(_ref, arg)) continue;
              args[arg] = _val(frameworkFilter[field][arg]);
            }
          }
        }
      }
      res = {};
      if (filter) {
        res.$filter = filter;
        res.$data = filterData;
      }
      if (page) {
        if (itemsPerPage == null) {
          itemsPerPage = 10;
        }
        res.$top = itemsPerPage;
        res.$skip = (page - 1) * itemsPerPage;
      }
      if (expand) {
        res.$expand = expand;
      }
      if (orderby) {
        res.$orderby = orderby;
      }
      if (args) {
        res.$args = args;
      }
      if (frameworkFilter.$isAction) {
        res.$isAction = frameworkFilter.$isAction;
      }
      return res;
    };
    return {
      convert: convert
    };
  });

}).call(this);
